#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

//Tabella hash
struct Node {
    int ric;
    int value;
    struct Node* next;
};

struct HashTable {
    int max;
    int size;
    struct Node** array;
};
typedef struct HashTable* Hash;

/*
//Forse si può rimuovere
bool is_prime(int num) {
    if (num <= 1) {
        return false;
    }

    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

//Forse si può rimuovere
int find_nearest_prime(int n) {
    if (n <= 1) {
        return -1; // Indica un errore o nessun primo trovato
    }

    if(is_prime(n)){
        return n;
    }

    int upper_prime = n + 1;
    while (!is_prime(upper_prime)) {
        upper_prime++;
    }

    return upper_prime;
}
*/

// Funzione di hash: restituisci il resto della divisione per la dimensione dell'array
unsigned int hashFunction(int value, int size) {
    unsigned int hash = 5381;
    hash = ((hash << 5) + hash) + value;
    return hash % size;
}

// Funzione per creare una nuova tabella hash con la dimensione specificata
struct HashTable* createHashTable(int size) {
    struct HashTable* table = (struct HashTable*)malloc(sizeof(struct HashTable));
    table->size = size;//size
    table->max = 0;
    table->array = (struct Node**)malloc(table->size * sizeof(struct Node*));
    for (int i = 0; i < table->size; i++) {
        table->array[i] = NULL;
    }
    return table;
}

// Funzione per cercare un elemento nella tabella hash dato la chiave
struct Node* search(struct HashTable* table, int value) {
    int index = hashFunction(value, table->size);
    struct Node* currentNode = table->array[index];
    while (currentNode != NULL) {
        if (currentNode->value == value){
            return currentNode;
        }
        currentNode = currentNode->next;
    }
    return NULL;
}

// Funzione per inserire un elemento nella tabella hash
void insert(struct HashTable* table, int value) {
    int index = hashFunction(value, table->size);
    struct Node* Node = search(table, value);
    if(Node != NULL){
        Node->ric++;
        return;
    }
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->value = value;
    newNode->ric = 1;
    newNode->next = table->array[index];
    table->array[index] = newNode;
    if(value > table->max)
        table->max = value;
    return;
}

// Funzione per trovare il massimo valore nella tabella hash
int find_max(struct HashTable* table){
    int max = 0;
    for(int i = 0; i < table->size; i++){               //Ciclo su tutti gli elementi della tabella
        struct Node* currentNode = table->array[i];
        while(currentNode != NULL){
            if(currentNode->value > max)
                max = currentNode->value;
            currentNode = currentNode->next;
        }
    }
    return max;
}

// Funzione per rimuovere un elemento dalla tabella hash dato la chiave
void removeNode(struct HashTable* table, int value) {
    int index = hashFunction(value, table->size);
    struct Node* currentNode = table->array[index];
    struct Node* prevNode = NULL;
    while (currentNode != NULL) {
        if (currentNode->value == value){          //Il nodo da eliminare è stato trovato
            if(currentNode->ric > 1){               //Se il nodo ha più di una ricorrenza, decrementa il contatore
                currentNode->ric--;
                printf("rottamata\n");
                return;
            }
            else{                                   //Altrimenti elimina il nodo
                if(prevNode != NULL) {
                    prevNode->next = currentNode->next;
                } else {
                    table->array[index] = currentNode->next;
                }
                if(currentNode->value == table->max)
                    table->max = find_max(table);
                free(currentNode);
                printf("rottamata\n");
                return; 
            }
        }
        prevNode = currentNode;
        currentNode = currentNode->next;
    }
    printf("non rottamata\n");
    return;
}

// Funzione per distruggere la tabella hash
void destroyHashTable(struct HashTable* table){
    if(table == NULL){
        return;
    }
    for(int i = 0;i<table->size;i++){
        struct Node* currentNode = table->array[i];
        while(currentNode != NULL){
            struct Node* temp = currentNode;
            currentNode = currentNode->next;
            free(temp);
        }
    }
    table->array = NULL;
    free(table->array);
    table = NULL;
    free(table);
}

// Funzione per stampare la tabella hash
void printHashTabele(struct HashTable* table){
    if(table == NULL){
        printf("La tabella e' vuota\n");
        return;
    }
    printf("Max: %d\n", table->max);
    for(int i = 0; i < table->size; i++){
        struct Node* currentNode = table->array[i];
        printf("%2d: ", i);
        while(currentNode != NULL){
            printf("%3d ", currentNode->value);
            printf("(%2d) ", currentNode->ric);
            currentNode = currentNode->next;
        }
        printf("\n");
    }
    return;
}
//  /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   //



//Albero
typedef struct nodo{
    int val;
    struct nodo* left;
    struct nodo* right;
    Hash Tabella;
}Nodo;
typedef Nodo* Albero;

Albero ultimo_nodo_aggiunto = NULL;

//Inserisci un nodo nell'albero
Albero Inserisci(Albero a, int elem, struct HashTable* table){
    if(a == NULL){
        Albero nuovo = (Albero)malloc(sizeof(Nodo));
        nuovo->val = elem;
        nuovo->left = NULL;
        nuovo->right = NULL;
        nuovo->Tabella = table;
        ultimo_nodo_aggiunto = nuovo;
        return nuovo;
    }
    if(elem < a->val){
        a->left = Inserisci(a->left, elem, table);
    }
    else{
        a->right = Inserisci(a->right, elem, table);
    }
    return a;
}

//Cerca un nodo nell'albero
Albero Cerca(Albero a, int elem){
    if(a == NULL){
        //printf("Elemento non trovato");
        return NULL;
    }
    if(a->val == elem){
        //printf("Elemento trovato");
        return a;
    }
    if(elem < a->val){
        return Cerca(a->left, elem);
    }
    else{
        return Cerca(a->right, elem);
    }
}

// Trova il nodo con il valore minimo nell'sottoalbero
Albero TrovaMinimo(Albero nodo) {
    while (nodo->left != NULL) {
        nodo = nodo->left;
    }
    return nodo;
}

// Rimuove un nodo con un determinato valore dall'albero
Albero RimuoviNodo(Albero radice, int valore) {
    if (radice == NULL) {
        printf("non demolita\n");
        return radice;
    }
    // Trova il nodo da rimuovere
    if (valore < radice->val) {
        radice->left = RimuoviNodo(radice->left, valore);
    } else if (valore > radice->val) {
        radice->right = RimuoviNodo(radice->right, valore);
    }
    else{
        // Caso 1: Nodo senza figli o con un solo figlio
        if (radice->left == NULL && radice->right == NULL) {
            destroyHashTable(radice->Tabella);
            free(radice);
            printf("demolita\n");
            return NULL;
        }else if (radice->left == NULL) {
            Nodo* temp = radice->right;
            destroyHashTable(radice->Tabella);
            free(radice);
            printf("demolita\n");
            return temp;
        } else if (radice->right == NULL) {
            Nodo* temp = radice->left;
            destroyHashTable(radice->Tabella);
            free(radice);
            printf("demolita\n");
            return temp;
        }

        Nodo* minimoSuccessore = TrovaMinimo(radice->right);
        radice->val = minimoSuccessore->val;
        destroyHashTable(radice->Tabella);
        radice->Tabella = minimoSuccessore->Tabella;
        radice->right = RimuoviNodo(radice->right, minimoSuccessore->val);
    }

    return radice;
}



void InOrder(Albero a){
    if(a == NULL){
        return;
    }
    InOrder(a->left);
    printf("Stazione: %d\nAuto:\n ", a->val);
    printHashTabele(a->Tabella);
    InOrder(a->right);
}

int main(){
    char input[20];
    int km, size, temp;
    Albero root = NULL;
    //Albero I_cant_lose_root = NULL,
    //Inizio lettura input
    scanf("%s", input);
    do{

        if(strcmp(input, "aggiungi-stazione") == 0){        //Gestisco aggiungi-stazione
            scanf("%d", &km);
            if(Cerca(root, km) != NULL){
                printf("non aggiunta\n");
            }
            else{
                scanf("%d", &size);
                    
                struct HashTable* table = createHashTable(size);

                for(int i=0;i<size;i++){
                    scanf("%d", &temp);
                    insert(table, temp);
                }
                root = Inserisci(root, km, table);
                printf("aggiunta %d\n", ultimo_nodo_aggiunto->val);
            }
        }
        
        //I_cant_lose_root = root;
        if(strcmp(input, "demolisci-stazione") == 0){
            scanf("%d", &km);
            root = RimuoviNodo(root, km);
        }


    }while(scanf("%s", input) != EOF);
    printf("Primo nodo aggiunto: %d\n", root->val);
    printf("Ultimo nodo aggiunto: %d\n", ultimo_nodo_aggiunto->val);
    //InOrder(root);
    return 0;
}
